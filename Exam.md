# Принцип DRY (Don’t Repeat Yourself)

**DRY** расшифровывается как **Don't Repeat Yourself** (с англ. "Не повторяйся"). Это принцип разработки программного обеспечения, направленный на сокращение повторения кода и логики.

## Суть принципа
Любая часть знания в системе должна иметь **единственное, непротиворечивое и авторитетное представление**. Вместо того чтобы дублировать один и тот же код в разных местах, его следует выносить в функции, классы или модули для повторного использования.

## Примеры

### ❌ Нарушение принципа DRY (повторяющийся код)

```python
# Плохо: одинаковый код повторяется
print("Сумма чисел от 1 до 10:")
sum1 = 0
for i in range(1, 11):
    sum1 += i
print(f"Результат: {sum1}")

print("Сумма чисел от 20 до 30:")
sum2 = 0
for i in range(20, 31):
    sum2 += i
print(f"Результат: {sum2}")

print("Сумма чисел от 35 до 45:")
sum3 = 0
for i in range(35, 46):
    sum3 += i
print(f"Результат: {sum3}")
```

### ✅ Соблюдение принципа DRY (без дублирования)

```python
# Хорошо: логика вынесена в функцию
def calculate_sum(start, end):
    """Вычисляет сумму чисел в диапазоне"""
    total = 0
    for i in range(start, end + 1):
        total += i
    return total

def print_sum(start, end):
    """Печатает результат вычисления суммы"""
    result = calculate_sum(start, end)
    print(f"Сумма чисел от {start} до {end}:")
    print(f"Результат: {result}")

# Использование функции
print_sum(1, 10)
print_sum(20, 30)
print_sum(35, 45)
```

## Преимущества соблюдения DRY:
- **Упрощение поддержки** — изменения нужно вносить только в одном месте
- **Снижение вероятности ошибок** — нет риска изменить код только в одном из мест дублирования
- **Повышение читаемости** — код становится более структурированным и понятным
- **Облегчение тестирования** — проще тестировать одну функцию, чем множество копий кода

**Принцип DRY применяется не только к коду, но и к конфигурациям, документации, базам данных и другим артефактам разработки.**

---

# Принцип KISS (Keep It Simple, Stupid)

**KISS** расшифровывается как **Keep It Simple, Stupid** (с англ. "Делай проще, дурак/глупец"). Более мягкий вариант перевода — "Будь проще" или "Делай проще".

## Объяснение своими словами
KISS означает, что код должен быть **максимально простым и понятным**. Не нужно усложнять решение там, где в этом нет необходимости. Чем проще код — тем легче его читать, понимать, поддерживать и отлаживать. Сложные конструкции могут выглядеть "круто", но часто делают код менее читаемым без реальной пользы для производительности или функциональности.

## Примеры

### ❌ Слишком сложный код (нарушение KISS)

```python
# Излишне сложное решение для фильтрации четных чисел
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Сложный однострочник с лямбда-функцией и фильтром
result = list(filter(lambda x: x % 2 == 0, numbers))

# Избыточная вложенность и сложные условия
def process_data(data):
    if data is not None:
        if isinstance(data, list):
            if len(data) > 0:
                if all(isinstance(item, (int, float)) for item in data):
                    return sum([x**2 for x in data if x > 0 and x % 2 == 0 or x % 3 == 0])
    return None
```

### ✅ Простой и понятный код (соблюдение KISS)

```python
# Простое решение для фильтрации четных чисел
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Простой цикл с понятной логикой
even_numbers = []
for num in numbers:
    if num % 2 == 0:
        even_numbers.append(num)

# Упрощенная версия с лучшей читаемостью
def process_data(data):
    if not data or not isinstance(data, list):
        return None
    
    # Проверяем, что все элементы - числа
    for item in data:
        if not isinstance(item, (int, float)):
            return None
    
    # Вычисляем сумму квадратов подходящих чисел
    total = 0
    for num in data:
        if num > 0 and (num % 2 == 0 or num % 3 == 0):
            total += num ** 2
    
    return total
```

### Пример переписывания генератора в обычный цикл

**❌ Сложный однострочник с генератором**

```python
# Задача: получить список квадратов положительных чисел
data = [-2, -1, 0, 1, 2, 3, 4]

# Сложный однострочник (хотя и рабочий)
result = [x**2 for x in data if x > 0]
```

**✅ Простой и понятный цикл**

```python
data = [-2, -1, 0, 1, 2, 3, 4]

# Простое решение с обычным циклом
result = []
for number in data:
    if number > 0:
        result.append(number ** 2)
```

## Ключевые идеи KISS:
- **Избегайте ненужной сложности** — если задача решается простым способом, не нужно искать "умное" решение
- **Приоритет читаемости** — код должен быть понятен даже новичку в проекте
- **Ясность важнее краткости** — короткий код не всегда лучше
- **Упрощайте условия** — разбивайте сложные условия на несколько простых
- **Избегайте глубокой вложенности** — если у вас много уровней вложенности, возможно, стоит пересмотреть архитектуру

**KISS не означает, что нужно всегда писать самый примитивный код.** Он означает, что решение должно быть адекватно сложности задачи. Если простая конструкция решает проблему — используйте её, а не сложную "продвинутую" альтернативу.

---

# ООП (Объектно-Ориентированное Программирование)

**Расшифровка:** Объектно-Ориентированное Программирование

## 4 ОСНОВНЫХ ПРИНЦИПА:

### 1️⃣ ИНКАПСУЛЯЦИЯ
**Суть:** Сокрытие внутренней реализации объекта и предоставление интерфейса для работы с ним.

**Python реализация:** `@property`, `@setter`, приватные атрибуты (`_attribute`, `__attribute`)

```python
class Cat:
    def __init__(self, age):
        self._age = age  # приватный атрибут
    
    @property
    def age(self):  # геттер
        return self._age
    
    @age.setter
    def age(self, value):  # сеттер с валидацией
        if value > self._age:
            self._age = value
```

### 2️⃣ НАСЛЕДОВАНИЕ
**Суть:** Создание новых классов на основе существующих, наследуя их свойства и методы.

**Python реализация:** `class Child(Parent)`

```python
class Animal:
    def speak(self):
        pass

class Cat(Animal):  # наследуем от Animal
    def speak(self):
        return "Meow!"
```

### 3️⃣ ПОЛИМОРФИЗМ
**Суть:** Возможность использовать объекты разных классов через единый интерфейс.

**Python реализация:** Перегрузка методов, duck typing

```python
def make_sound(animal):
    return animal.speak()  # работает с любым объектом, имеющим метод speak()

cat = Cat()
dog = Dog()  # Dog тоже имеет метод speak()
print(make_sound(cat))  # Meow!
print(make_sound(dog))  # Woof!
```

### 4️⃣ АБСТРАКЦИЯ
**Суть:** Упрощение сложных систем путем выделения существенных характеристик и скрытия деталей.

**Python реализация:** Абстрактные базовые классы (ABC), интерфейсы

```python
from abc import ABC, abstractmethod

class Predator(ABC):  # абстрактный класс
    @abstractmethod
    def hunt(self):  # абстрактный метод
        pass

class Cat(Predator):
    def hunt(self):  # обязательная реализация
        return "Hunting mice..."
```

## Практические примеры

### Базовый пример ООП

```python
# Класс - шаблон для создания объектов
class Animal:
    def __init__(self, name, age):
        self.name = name  # атрибут
        self.age = age    # атрибут
    
    def speak(self):      # метод
        print(f"{self.name} издает звук")

# Наследование
class Dog(Animal):
    def speak(self):      # полиморфизм
        print(f"{self.name} гавкает")

class Cat(Animal):
    def speak(self):
        print(f"{self.name} мяукает")

# Создание объектов
dog = Dog("Шарик", 3)
cat = Cat("Мурка", 2)

# Использование полиморфизма
animals = [dog, cat]
for animal in animals:
    animal.speak()
    # Вывод:
    # Шарик гавкает
    # Мурка мяукает
```

### Пример с инкапсуляцией

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance  # инкапсуляция
    
    def deposit(self, amount):
        self.__balance += amount
    
    def withdraw(self, amount):
        if amount <= self.__balance:
            self.__balance -= amount
            return amount
        return 0
    
    def get_balance(self):
        return self.__balance

# Использование
account = BankAccount("Иван", 1000)
account.deposit(500)
print(account.get_balance())  # 1500
account.withdraw(200)
print(account.get_balance())  # 1300
```
